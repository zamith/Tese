Databases have been in use since the earliest days of electronic computing. Originally \ac{dbms}s were found only in large organizations with the computer hardware needed to support large data sets and systems tightly linked to custom databases. There was, obviously, a need for general-purpose database systems and for a standard, which appeared in 1971 proposed by CODASYL \cite{taylor1976codasyl}. They were known as navigational \ac{dbms}s.

This approach had one big missing part, the capability of searching, which was bridged by Edgar Codd's relational model \cite{codd1970relational} in the 1970s. This model is often referred to when talking about the \ac{sql} model, which appeared shortly after and was loosely based on it.

The \ac{sql} model uses almost the same tables and structure of the relational model, with the difference that it added a, by then standardized, querying language, \ac{sql}.

In the last few years, these models have gone from big, monolithic entities to individual users, this made it necessary for them to be more modular and easier to set up. Other then that, with the increasing usage of the internet by every kind of business, there has also been a big increase on the usage of \emph{the cloud}\footnote{``Cloud computing is Internet-based computing, whereby shared servers provide resources, software, and data to computers and other devices on demand, as with the electricity grid.'' - \url{http://en.wikipedia.org/wiki/Cloud_computing} (11/1/2011)}.

Distributed databases \cite{ozsu91distributeddatabase} have had an enormous growth with the massified usage of social networks, such as Facebook\footnote{\url{www.facebook.com}}. However, this does not imply that relational databases have been outdated. In order to understand the actual differences between these ways of storing and retrieving data one has to take a closer look at each of them. In doing so, we might find that they are not that incompatible, and that some benefits can be taken from a mix of both.

On one hand there is the NoSQL approach, which offers higher scalability, meaning that it can run faster and support bigger loads. On the other hand, a \ac{rdbms} offers more consistency as well as much more powerful query capabilities and a lot of knowledge and expertise gained over the years \cite{stonebraker2010sql}.


\section{Problem Statement}

Since its appearance in 2009 the NoSQL movement and its implementations have raised a lot of followers, not as many, however, as those who are still using relational databases. In each of them it seems that the goods things are tightly coupled with the ``bad'' and that they are on completely opposing sides, leaving a common ground between them that is just now beginning to be explored. Since databases, both relational and distributed, are widely used, this common ground becomes a very interesting topic of investigation.

Being distributed, NoSQL databases do not provide strong consistency in order to provided partition tolerance and availability, so important in scalable systems.

Also, they lack a standardized query language such as \ac{sql}. Their reduced API makes it simpler to do operations as a \emph{get} or a \emph{put}, but harder to perform more complex queries and sometimes even impossible, as they do not provide a transactional system. 

This problems does not occur in the relational world, where extensive work has been done in all of these areas. Still, given that they provide strong consistency and full ACID properties, relational databases do not scale as well specially horizontally.

\section{Objectives}

These two data management philosophies differ in many points, and usually, one is chosen, depending on the project requirements.
\begin{quote}
If you want to work with a lot of data and be able to run dynamic ad-hoc queries on it, you use a relational database with \ac{sql}. Using a key value store doesn't make any sense for that unless you want to easily be able to distribute your workload on several machines without having to go though the hassle of setting up a relational database cluster. If you want to just keep your objects in a persistent state and have high-performance access to them (e.g. a LOT of web applications), use a key value store.
\end{quote} 
\begin{flushright}in \url{http://buytaert.net/nosql-and-sql}, 25/11/2010\end{flushright}
	
In many cases this will lead to having to write different code to access different kinds of data, or using a polyglot \ac{orm}\footnote{An orm that outputs different code, according to the database in use, in spite of receiving the same input} as Ruby's DataMapper \cite{DM}, and in most of the cases this probably is not a very big problem, but nonetheless, it will make your code dependent of the \ac{dbms} you use. Another problem arises when you have legacy code you want to migrate from an \ac{sql} based \ac{dbms} to a NoSQL system. 	
 
This work is going to try and bridge this gap by building a layer between the \ac{sql} code and interpreter, and the actual database underneath it, providing a way to run \ac{sql} queries on top of a NoSQL system (eg: Cassandra), at the cost of a possible reduction on performance.



%The main objective of this work is to reach an intermediate point between a \ac{rdbms} and a fully distributed database, taking the major properties from each and merging them. These major properties are the ability to query the database with \ac{sql} and the ACID properties from the \ac{rdbms}, and the scalability from its distributed counterpart.   
%
%For that, it is necessary to understand how both of them work to find out how this merging can be done. There are some features that cannot be kept solely by the merging of the two, in those cases it is necessary to provide the appropriate mechanisms in order to achieve said features.

% O comando \label{nome} define o marcador da parte especificada.
% Você pode citar esta seção usando o comando \ref{nome}.
% O "~" evita uma quebra de linha entre as palavras.

% O Capítulo~\ref{intro} é uma introdução ao contexto do projeto.
% Aqui vou exemplificar alguns comandos básicos e úteis para uma dissertação como incluir citações \cite{SJ07}.

% Veja mais formas de fazer citações no texto da documentação do natbib.
% O \texttt{natbib} é um ótimo pacote, pois é flexível \cite[ver detalhes em][]{Kirk2008}.
% \citet{Emlet1987} mostra outro modo de citar trabalhos no texto e como grafar o nome das espécies \emph{Drosophila~melagonaster} e \emph{Clypeaster~subdepressus}.
% Neste caso o uso do "~" foi por opção.

\section{Contributions}

This thesis proposes a new approach to \ac{rdbms} by altering the underlying storage system using Apache Derby DB and Apache Cassandra.
The major factor in this implementation is that it takes advantage of the scalability and replication features from Cassandra, and allies them with Derby's SQL engine. Also, it provides a completely separate library for fully distributed transactions using Cassandra and Cages. 

In detail, we make the following contributions:

\begin{itemize}
	\item \textbf{Development of a proof of concept on using NoSQL with SQL}\\
		This contribution addresses the lack of a proof that this integration could be achieved without incurring into too much of an overhead. We evaluate this proof of concept with the TPC-W benchmark\cite{tpcw} to get a bottom line with which to access the overhead of having our transactional system. 
		
	\item \textbf{Development of a distributed transactions library for Cassandra}\\
		We developed a fully distributed transactions library for Cassandra that uses Cages and Zookeeper, completed with a unit tests suite.
		
	\item \textbf{Evaluation and performance analysis of the proposed solution}\\
		We evaluate the developed solution using realistic workloads based on the interactions with the database from the TPC-W benchmark\cite{tpcw}. We analyze the behavior of the solution under different conditions and configurations comparing it to the standard Derby system.
\end{itemize}


\section{Dissertation Outline}

This thesis is organized as follows: Chapter 2 describes the main features and differences between SQL DBMSs and NoSQL; Chapter 3 introduces the related work, with a special emphasis on distributed transactions ; Chapter 4 describes the most relevant features of Derby and presents the changes made to it; Chapter 5 describes the same things as Chapter 4, but for Cassandra; Chapter 6 introduces the proposed solution for distributed transaction in a peer-to-peer database, namely Cassandra; Chapter 7 evaluates the solution implemented using realistic workloads; and finally Chapter 8 concludes the thesis, summarizing its contributions and describing possible future work. 

% Mencionei na seção~\ref{intro:problem} como citar um capítulo.
% O modelo está dividido em 2 capítulos, sendo que o Capítulo~\ref{cap2} trata de um assunto (e.g., um artigo decorrente da sua pesquisa) enquanto o Capítulo~\ref{cap3} aborda outro.

% O comando abaixo faz com que uma página em branco seja incluída após o fim do capítulo.
% Use-o caso você precise criar uma página em branco para que os capítulos se iniciem sempre em páginas ímpares.
% Também é útil para deixar as páginas certas e contadas para a impressão.

% \clearpage{\pagestyle{empty}\cleardoublepage}
